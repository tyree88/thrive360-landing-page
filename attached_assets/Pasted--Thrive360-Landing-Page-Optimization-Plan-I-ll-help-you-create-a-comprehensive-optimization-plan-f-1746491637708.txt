# Thrive360 Landing Page Optimization Plan

I'll help you create a comprehensive optimization plan for the Thrive360 landing page with a particular focus on animation performance. First, let's explore a Problem Section design that will effectively transition from your hero section.

## Problem Section Concept

Based on your needs, I recommend a **Scrolling Reveal Format with Staggered Animation** that:
- Creates visual interest through animations
- Establishes the problems Thrive360 solves 
- Maintains performance through optimized implementation

### Problem Section Implementation

Here's how I'd structure the `ProblemSection.tsx` component:

```tsx
'use client';

import { useRef, useEffect } from 'react';
import { motion } from 'framer-motion';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/dist/ScrollTrigger';
import { useBatchReveal } from '@/hooks/useBatchReveal';
import { problemStatistics } from '@/constants/statistics';

const ProblemSection = () => {
  const sectionRef = useRef<HTMLDivElement>(null);
  const statsRefs = useRef<HTMLDivElement[]>([]);
  const { reveal } = useBatchReveal();
  
  useEffect(() => {
    // Register ScrollTrigger plugin
    gsap.registerPlugin(ScrollTrigger);
    
    if (!sectionRef.current) return;
    
    // Create a GSAP context for clean unmount
    const ctx = gsap.context(() => {
      // Animation timeline
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: sectionRef.current,
          start: 'top 75%',
          end: 'bottom 50%',
          toggleActions: 'play none none reverse',
          markers: process.env.NODE_ENV === 'development',
        }
      });
      
      // Counter animations
      statsRefs.current.forEach((statRef, index) => {
        const valueElement = statRef.querySelector('.stat-value');
        const targetValue = problemStatistics[index].value;
        const unit = problemStatistics[index].unit || '';
        
        tl.fromTo(
          statRef,
          { opacity: 0, y: 50 },
          { 
            opacity: 1, 
            y: 0, 
            duration: 0.8, 
            ease: 'power3.out',
            onStart: () => {
              // Counter animation
              gsap.to(valueElement, {
                innerHTML: targetValue,
                duration: 2,
                snap: { innerHTML: 1 }, // Ensures integer counting
                onUpdate: function() {
                  valueElement.innerHTML = Math.floor(this.targets()[0].innerHTML) + unit;
                }
              });
            }
          },
          index * 0.2 // Stagger effect
        );
      });
      
    }, sectionRef); // GSAP context scoped to section
    
    // Cleanup function
    return () => ctx.revert();
  }, []);
  
  return (
    <section
      ref={sectionRef}
      className="py-20 px-6 md:px-12 bg-gradient-to-br from-gray-50 to-gray-100 overflow-hidden"
      aria-label="Industry challenges"
    >
      <div className="container mx-auto max-w-6xl">
        <motion.h2
          initial={{ opacity: 0, y: 30 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true, margin: "-100px" }}
          transition={{ duration: 0.6 }}
          className="text-3xl md:text-4xl lg:text-5xl font-bold text-center mb-16 text-gray-900"
        >
          The Wellbeing Crisis Is Affecting Your Business
        </motion.h2>
        
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
          {problemStatistics.map((stat, index) => (
            <div
              key={stat.id}
              ref={el => statsRefs.current[index] = el as HTMLDivElement}
              className="bg-white rounded-xl shadow-lg p-8 transform transition-all duration-500 ease-out hover:scale-105"
            >
              <div className="flex items-center justify-center h-20 w-20 rounded-full bg-gradient-to-r from-purple-500 to-blue-500 text-white mx-auto mb-6">
                {stat.icon}
              </div>
              <h3 className="text-2xl font-bold text-center mb-2 text-gray-800">
                <span className="stat-value">0</span> {/* Will be animated */}
              </h3>
              <p className="text-center text-gray-600">{stat.description}</p>
            </div>
          ))}
        </div>
        
        <div className="mt-16 text-center" {...reveal}>
          <p className="text-xl text-gray-700 max-w-3xl mx-auto">
            Traditional wellness programs fail to address these challenges, 
            resulting in low engagement and minimal impact on employee wellbeing.
          </p>
          <motion.div 
            initial={{ opacity: 0, y: 20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true }}
            transition={{ delay: 0.4, duration: 0.6 }}
          >
            <a href="#solution" className="mt-8 inline-block px-8 py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white font-medium rounded-lg transition-all duration-300 hover:shadow-lg">
              Discover the Solution
            </a>
          </motion.div>
        </div>
      </div>
    </section>
  );
};

export default ProblemSection;
```

And for the supporting constants file:

```tsx
// constants/statistics.ts

import { ReactNode } from 'react';
import { FaChartLine, FaUserTimes, FaHeartbeat } from 'react-icons/fa';

export interface ProblemStatistic {
  id: string;
  value: number;
  unit: string;
  description: string;
  icon: ReactNode;
}

export const problemStatistics: ProblemStatistic[] = [
  {
    id: 'productivity-loss',
    value: 67,
    unit: '%',
    description: 'Of employees report decreased productivity due to mental health challenges',
    icon: <FaChartLine className="w-10 h-10" />,
  },
  {
    id: 'program-engagement',
    value: 23,
    unit: '%',
    description: 'Average engagement rate with traditional wellness programs',
    icon: <FaUserTimes className="w-10 h-10" />,
  },
  {
    id: 'business-impact',
    value: 300,
    unit: 'B',
    description: 'Annual cost of employee wellness issues to businesses globally (USD)',
    icon: <FaHeartbeat className="w-10 h-10" />,
  },
];
```

Now, let's develop a comprehensive optimization plan to address all the performance issues mentioned.

## Current Performance Analysis

### Animation and Hydration Issues

1. **Layout Shifts During Hydration**
   - GSAP and Framer Motion initialization during hydration causes content jumps
   - Initial state differences between server-rendered HTML and client initialization
   - Delayed smooth scrolling initialization creates scroll position jumps

2. **Animation Performance Bottlenecks**
   - Multiple animation libraries competing for the main thread
   - Excessive DOM manipulation during scroll events
   - Unoptimized parallax effects causing GPU strain on mobile
   - Large component trees being animated simultaneously

3. **Integration Issues**
   - Race conditions between Lenis initialization and GSAP ScrollTrigger
   - Conflicting scroll listeners between animation systems
   - Non-optimized dynamic imports causing sequential loading delays

## Component Architecture Optimization

### Server vs Client Component Strategy

```tsx
// app/(routes)/page.tsx - Server Component
import dynamic from 'next/dynamic';
import { Suspense } from 'react';
import StaticHero from '@/components/sections/Hero/StaticHero';
import StaticProblem from '@/components/sections/Problem/StaticProblem';
import LoadingFallback from '@/components/common/LoadingFallback';

// Dynamic imports with client-side animation
const AnimatedHero = dynamic(() => 
  import('@/components/sections/Hero/AnimatedHero'), 
  { ssr: false, loading: () => <StaticHero /> }
);

const AnimatedProblem = dynamic(() => 
  import('@/components/sections/Problem/AnimatedProblem'), 
  { ssr: false, loading: () => <StaticProblem /> }
);

export default function Home() {
  return (
    <main>
      {/* Static SSR version shown immediately */}
      <Suspense fallback={<StaticHero />}>
        <AnimatedHero />
      </Suspense>
      
      <Suspense fallback={<StaticProblem />}>
        <AnimatedProblem />
      </Suspense>
      
      {/* Additional sections */}
    </main>
  );
}
```

### Animation Libraries Code Splitting

```tsx
// lib/animation.ts - Optimized dynamic imports
import { useEffect, useState } from 'react';

export function useAnimationLibraries() {
  const [libraries, setLibraries] = useState<{
    gsap?: any;
    scrollTrigger?: any;
    motion?: any;
    lenis?: any;
  }>({});
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadLibraries = async () => {
      try {
        // Parallel loading of animation libraries
        const [
          { gsap },
          { ScrollTrigger },
          { motion },
          { default: Lenis }
        ] = await Promise.all([
          import('gsap'),
          import('gsap/dist/ScrollTrigger'),
          import('framer-motion'),
          import('@studio-freight/lenis')
        ]);
        
        // Register GSAP plugins
        gsap.registerPlugin(ScrollTrigger);
        
        setLibraries({
          gsap,
          scrollTrigger: ScrollTrigger,
          motion,
          lenis: Lenis
        });
      } catch (error) {
        console.error('Failed to load animation libraries:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadLibraries();
  }, []);
  
  return { ...libraries, loading };
}
```

## Animation System Enhancements

### Optimized Lenis Integration

```tsx
// hooks/useLenis.ts - Enhanced Lenis hook
import { useEffect, useRef, useState } from 'react';

export function useLenis() {
  const [lenis, setLenis] = useState<any>(null);
  const requestRef = useRef<number>();
  const previousTimeRef = useRef<number>();
  
  useEffect(() => {
    // Only import Lenis on the client
    const initLenis = async () => {
      const Lenis = (await import('@studio-freight/lenis')).default;
      
      // Create Lenis instance with optimized settings
      const lenisInstance = new Lenis({
        duration: 1.2,
        easing: (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
        orientation: 'vertical',
        gestureOrientation: 'vertical',
        smoothWheel: true,
        wheelMultiplier: 1,
        smoothTouch: false, // Disable on touch for better performance
        infinite: false,
      });
      
      // Add reduced motion media query support
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      if (prefersReducedMotion.matches) {
        lenisInstance.destroy();
        setLenis(null);
        return;
      }
      
      // Lenis animation frame using requestAnimationFrame
      const raf = (time: number) => {
        if (previousTimeRef.current !== undefined) {
          lenisInstance.raf(time);
        }
        previousTimeRef.current = time;
        requestRef.current = requestAnimationFrame(raf);
      };
      
      // Start animation loop
      requestRef.current = requestAnimationFrame(raf);
      setLenis(lenisInstance);
      
      // Expose to window for GSAP integration
      window.lenis = lenisInstance;
      
      // Dispatch custom event for other components to know Lenis is ready
      window.dispatchEvent(new CustomEvent('lenis:ready'));
    };
    
    // Wait for document to be fully loaded to avoid layout shifts
    if (typeof window !== 'undefined') {
      if (document.readyState === 'complete') {
        initLenis();
      } else {
        window.addEventListener('load', initLenis);
        return () => window.removeEventListener('load', initLenis);
      }
    }
    
    // Cleanup function
    return () => {
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
      }
      if (lenis) {
        lenis.destroy();
      }
    };
  }, []);
  
  return lenis;
}
```

### GSAP and Framer Motion Integration

```tsx
// hooks/useScrollTriggerAnimation.ts - Optimized ScrollTrigger hook
import { useEffect, useRef } from 'react';

export function useScrollTriggerAnimation(
  trigger: React.RefObject<HTMLElement>,
  animationConfig: any,
  dependencies: any[] = []
) {
  const timeline = useRef<any>(null);
  const initialized = useRef(false);
  
  useEffect(() => {
    // Skip if already initialized or no trigger element
    if (initialized.current || !trigger.current) return;
    
    // Load GSAP and ScrollTrigger only on client
    const initGSAP = async () => {
      try {
        const { gsap } = await import('gsap');
        const { ScrollTrigger } = await import('gsap/dist/ScrollTrigger');
        gsap.registerPlugin(ScrollTrigger);
        
        // Wait for Lenis to initialize
        const waitForLenis = () => {
          return new Promise<void>((resolve) => {
            if (window.lenis) {
              resolve();
            } else {
              window.addEventListener('lenis:ready', () => resolve(), { once: true });
            }
          });
        };
        
        await waitForLenis();
        
        // Integrate Lenis with ScrollTrigger
        ScrollTrigger.scrollerProxy(document.documentElement, {
          scrollTop(value) {
            if (arguments.length) {
              window.lenis?.scrollTo(value);
            }
            return window.lenis?.scroll || window.scrollY;
          },
          getBoundingClientRect() {
            return {
              top: 0, 
              left: 0, 
              width: window.innerWidth, 
              height: window.innerHeight
            };
          }
        });
        
        // Update ScrollTrigger on Lenis scroll
        window.lenis?.on('scroll', () => {
          ScrollTrigger.update();
        });
        
        // Create animation timeline
        const ctx = gsap.context(() => {
          timeline.current = gsap.timeline({
            scrollTrigger: {
              trigger: trigger.current,
              ...animationConfig.scrollTrigger
            },
            ...animationConfig.timeline
          });
          
          // Execute animation callback with timeline
          if (typeof animationConfig.animation === 'function') {
            animationConfig.animation(timeline.current, gsap);
          }
        }, trigger);
        
        initialized.current = true;
        
        // Cleanup function
        return () => {
          ctx.revert();
          if (timeline.current) {
            timeline.current.kill();
          }
        };
      } catch (error) {
        console.error('Failed to initialize GSAP animation:', error);
      }
    };
    
    initGSAP();
  }, [trigger, animationConfig, ...dependencies]);
  
  return timeline.current;
}
```

### Layout Shift Prevention

```tsx
// hooks/useRevealAnimation.ts - Optimized reveal animation with CLS prevention
import { useEffect, useRef } from 'react';
import { useInView } from 'react-intersection-observer';

export function useRevealAnimation({
  threshold = 0.2,
  triggerOnce = true,
  rootMargin = '-100px 0px',
} = {}) {
  const animatedRef = useRef<HTMLElement>(null);
  const { ref: inViewRef, inView } = useInView({
    threshold,
    triggerOnce,
    rootMargin,
  });
  
  // Combine refs
  const setRefs = (element: HTMLElement | null) => {
    // Update the inViewRef
    inViewRef(element);
    // Store for direct access
    animatedRef.current = element;
  };
  
  useEffect(() => {
    if (!animatedRef.current) return;
    
    // Pre-compute dimensions to prevent layout shift
    const element = animatedRef.current;
    const { height } = element.getBoundingClientRect();
    
    // Set initial styles to prevent layout shift
    element.style.height = `${height}px`;
    element.style.opacity = '0';
    element.style.transform = 'translateY(20px)';
    element.style.transition = 'none';
    
    // Release height constraint after initial render
    requestAnimationFrame(() => {
      element.style.height = '';
      element.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
    });
    
    // Animate when in view
    if (inView) {
      requestAnimationFrame(() => {
        element.style.opacity = '1';
        element.style.transform = 'translateY(0)';
      });
    }
  }, [inView]);
  
  return { ref: setRefs, inView };
}
```

## Implementation Guide

### Optimized Animation Hooks

```tsx
// hooks/useBatchReveal.ts - Performance optimized batch reveal
import { useRef, useEffect } from 'react';

export function useBatchReveal(options = {}) {
  const elements = useRef<Set<HTMLElement>>(new Set());
  const observer = useRef<IntersectionObserver | null>(null);
  
  useEffect(() => {
    // Only run on client
    if (typeof window === 'undefined') return;
    
    // Initialize Intersection Observer
    observer.current = new IntersectionObserver((entries) => {
      // Batch DOM operations in a single animation frame
      const visibleElements: HTMLElement[] = [];
      
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          visibleElements.push(entry.target as HTMLElement);
          observer.current?.unobserve(entry.target);
        }
      });
      
      // Apply animations in a single frame
      if (visibleElements.length > 0) {
        requestAnimationFrame(() => {
          visibleElements.forEach((element, index) => {
            // Staggered animation
            setTimeout(() => {
              element.style.opacity = '1';
              element.style.transform = 'translateY(0)';
            }, index * 100); // 100ms stagger
          });
        });
      }
    }, {
      threshold: 0.15,
      rootMargin: '-50px 0px',
      ...options
    });
    
    // Return cleanup function
    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [options]);
  
  // Register element to be observed
  const register = (element: HTMLElement | null) => {
    if (!element || !observer.current) return;
    
    // Set initial styles
    element.style.opacity = '0';
    element.style.transform = 'translateY(20px)';
    element.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
    
    // Observe element
    observer.current.observe(element);
    elements.current.add(element);
  };
  
  // Attach to JSX element
  const reveal = {
    ref: register
  };
  
  return { reveal, register };
}
```

### Component Refactoring Example

Before:
```tsx
// Before: Inefficient animation component
const AnimatedSection = () => {
  useEffect(() => {
    // Load GSAP directly
    const gsap = require('gsap');
    const ScrollTrigger = require('gsap/ScrollTrigger');
    gsap.registerPlugin(ScrollTrigger);
    
    // Multiple separate animations
    gsap.from('.heading', { 
      opacity: 0, 
      y: 50, 
      duration: 1,
      scrollTrigger: {
        trigger: '.section',
        start: 'top 80%',
      }
    });
    
    gsap.from('.card', { 
      opacity: 0, 
      y: 50, 
      duration: 1,
      stagger: 0.2,
      scrollTrigger: {
        trigger: '.section',
        start: 'top 80%',
      }
    });
    
    // More animations...
  }, []);
  
  return (
    <section className="section">
      <h2 className="heading">Section Title</h2>
      <div className="grid">
        <div className="card">Card 1</div>
        <div className="card">Card 2</div>
        <div className="card">Card 3</div>
      </div>
    </section>
  );
};
```

After:
```tsx
// After: Optimized animation component
'use client';

import { useRef } from 'react';
import { useScrollTriggerAnimation } from '@/hooks/useScrollTriggerAnimation';

const AnimatedSection = () => {
  const sectionRef = useRef<HTMLElement>(null);
  const headingRef = useRef<HTMLHeadingElement>(null);
  const cardsRef = useRef<HTMLDivElement>(null);
  
  // Use optimized hook
  useScrollTriggerAnimation(
    sectionRef,
    {
      scrollTrigger: {
        start: 'top 80%',
        end: 'bottom 20%',
        toggleActions: 'play none none reverse',
      },
      animation: (timeline: any, gsap: any) => {
        // Single timeline for all animations
        if (headingRef.current) {
          timeline.fromTo(
            headingRef.current,
            { opacity: 0, y: 50 },
            { opacity: 1, y: 0, duration: 0.8 }
          );
        }
        
        if (cardsRef.current) {
          // Use children method instead of className selector
          const cards = cardsRef.current.children;
          timeline.fromTo(
            cards,
            { opacity: 0, y: 50 },
            { 
              opacity: 1, 
              y: 0, 
              duration: 0.8,
              stagger: 0.2,
              ease: 'power2.out',
              clearProps: 'transform' // Free up resources after animation
            },
            '-=0.4' // Overlap with previous animation
          );
        }
      }
    }
  );
  
  return (
    <section ref={sectionRef} className="py-20 px-6 relative overflow-hidden">
      <div className="container mx-auto max-w-6xl">
        <h2 
          ref={headingRef}
          className="text-3xl md:text-4xl font-bold mb-12 will-change-transform"
        >
          Section Title
        </h2>
        <div 
          ref={cardsRef}
          className="grid md:grid-cols-3 gap-8"
        >
          <div className="bg-white rounded-lg shadow-md p-6 will-change-transform">Card 1</div>
          <div className="bg-white rounded-lg shadow-md p-6 will-change-transform">Card 2</div>
          <div className="bg-white rounded-lg shadow-md p-6 will-change-transform">Card 3</div>
        </div>
      </div>
    </section>
  );
};
```

## Monitoring and Maintenance

### Animation Performance Metrics Tracking

```tsx
// utils/performance-monitoring.ts
export const initAnimationPerformanceMonitoring = () => {
  // Only run in production
  if (process.env.NODE_ENV !== 'production') return;
  
  // Animation frames per second monitoring
  let frameTimes: number[] = [];
  let lastFrameTime = performance.now();
  
  // FPS counter
  const measureFPS = () => {
    const now = performance.now();
    const delta = now - lastFrameTime;
    lastFrameTime = now;
    
    // Store frame times for the last second
    frameTimes.push(delta);
    
    // Keep only frames from the last second
    const timeLimit = now - 1000;
    while (frameTimes.length > 0 && frameTimes[0] < timeLimit) {
      frameTimes.shift();
    }
    
    // Calculate FPS
    const fps = frameTimes.length;
    
    // Report if FPS drops below threshold
    if (fps < 45) {
      // Send to analytics
      logPerformanceIssue('low-fps', { fps, timestamp: now });
    }
    
    requestAnimationFrame(measureFPS);
  };
  
  // Start measuring
  requestAnimationFrame(measureFPS);
  
  // Layout shift detection for animations
  let cumulativeLayoutShift = 0;
  
  // Observer for layout shifts
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      // Only measure layout shifts during animations
      if (document.body.classList.contains('is-animating')) {
        // @ts-ignore - LayoutShift is not in TypeScript's lib yet
        const value = entry.value;
        cumulativeLayoutShift += value;
        
        // Report significant shifts
        if (value > 0.05) {
          logPerformanceIssue('animation-cls', {
            value,
            timestamp: performance.now()
          });
        }
      }
    }
  });
  
  // Start observing layout shifts
  observer.observe({ type: 'layout-shift', buffered: true });
  
  // Animation start/end tracking
  document.addEventListener('animation:start', () => {
    document.body.classList.add('is-animating');
  });
  
  document.addEventListener('animation:end', () => {
    document.body.classList.remove('is-animating');
  });
};

// Log performance issues to analytics
const logPerformanceIssue = (type: string, data: any) => {
  // Send to analytics service
  console.warn(`Performance issue detected: ${type}`, data);
  
  // Example integration with Web Vitals
  if (window.gtag) {
    window.gtag('event', 'performance_issue', {
      event_category: 'animation',
      event_label: type,
      value: type === 'low-fps' ? data.fps : Math.round(data.value * 100),
    });
  }
};
```

## Final Implementation Plan

1. **Fix Core Structure (Week 1)**
   - Separate animation logic from component rendering
   - Implement static and animated component versions
   - Create optimized animation hooks

2. **Optimize Animation Libraries (Week 2)**
   - Implement efficient dynamic imports
   - Create proper Lenis integration with GSAP
   - Set up unified animation system

3. **Performance Monitoring (Week 3)**
   - Implement animation-specific metrics
   - Set up Core Web Vitals monitoring
   - Create regression testing for animations

4. **Accessibility & Polish (Week 4)**
   - Implement reduced motion preferences
   - Fix all remaining layout shifts
   - Final performance optimization for mobile

With this comprehensive plan, you'll achieve significant performance improvements while maintaining the visual fidelity of your animations. The structure separates concerns, optimizes the animation systems, and creates a sustainable architecture for future enhancements.

Would you like me to elaborate on any specific aspect of this optimization plan or go deeper into any particular implementation detail for the Problem Section component?