"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_gsap_ScrollToPlugin_js"],{

/***/ "(app-pages-browser)/./node_modules/gsap/ScrollToPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/ScrollToPlugin.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollToPlugin: () => (/* binding */ ScrollToPlugin),\n/* harmony export */   \"default\": () => (/* binding */ ScrollToPlugin)\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _window,\n    _docEl,\n    _body,\n    _toArray,\n    _config,\n    ScrollTrigger,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _max = function _max(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n},\n    _buildGetter = function _buildGetter(e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _clean = function _clean(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {},\n        p;\n\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n\n    return result;\n  }\n},\n    _getOffset = function _getOffset(element, container) {\n  element = _toArray(element)[0];\n\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n},\n    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (_windowExists() && gsap && typeof document !== \"undefined\" && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\n\nvar ScrollToPlugin = {\n  version: \"3.13.0\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this,\n        snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!(\"autoKill\" in value ? value : _config).autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        target = data.target,\n        tween = data.tween,\n        autoKill = data.autoKill,\n        xPrev = data.xPrev,\n        yPrev = data.yPrev,\n        isWin = data.isWin,\n        snap = data.snap,\n        snapInline = data.snapInline,\n        x,\n        y,\n        yDif,\n        xDif,\n        threshold;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n\n    if (data.y < 0) {\n      data.y = 0;\n    }\n\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n    ScrollTrigger && ScrollTrigger.update();\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\",\n        i = this._props.indexOf(property);\n\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n\n    i > -1 && this._props.splice(i, 1);\n    return !this._props.length;\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n\nScrollToPlugin.config = function (vars) {\n  _config || _initCore() || (_config = gsap.config()); // in case the window hasn't been defined yet.\n\n  for (var p in vars) {\n    _config[p] = vars[p];\n  }\n};\n\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRvUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxPQUFPO0FBQ1AsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2dzYXAvU2Nyb2xsVG9QbHVnaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUb1BsdWdpbiAzLjEzLjBcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2VcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luZG93LFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfdG9BcnJheSxcbiAgICBfY29uZmlnLFxuICAgIFNjcm9sbFRyaWdnZXIsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9tYXggPSBmdW5jdGlvbiBfbWF4KGVsZW1lbnQsIGF4aXMpIHtcbiAgdmFyIGRpbSA9IGF4aXMgPT09IFwieFwiID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIixcbiAgICAgIHNjcm9sbCA9IFwic2Nyb2xsXCIgKyBkaW0sXG4gICAgICBjbGllbnQgPSBcImNsaWVudFwiICsgZGltO1xuICByZXR1cm4gZWxlbWVudCA9PT0gX3dpbmRvdyB8fCBlbGVtZW50ID09PSBfZG9jRWwgfHwgZWxlbWVudCA9PT0gX2JvZHkgPyBNYXRoLm1heChfZG9jRWxbc2Nyb2xsXSwgX2JvZHlbc2Nyb2xsXSkgLSAoX3dpbmRvd1tcImlubmVyXCIgKyBkaW1dIHx8IF9kb2NFbFtjbGllbnRdIHx8IF9ib2R5W2NsaWVudF0pIDogZWxlbWVudFtzY3JvbGxdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZGltXTtcbn0sXG4gICAgX2J1aWxkR2V0dGVyID0gZnVuY3Rpb24gX2J1aWxkR2V0dGVyKGUsIGF4aXMpIHtcbiAgLy9wYXNzIGluIGFuIGVsZW1lbnQgYW5kIGFuIGF4aXMgKFwieFwiIG9yIFwieVwiKSBhbmQgaXQnbGwgcmV0dXJuIGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoYXQgZWxlbWVudCAobGlrZSBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCwgYWx0aG91Z2ggaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHdpbmRvdywgaXQnbGwgdXNlIHRoZSBwYWdlWE9mZnNldC9wYWdlWU9mZnNldCBvciB0aGUgZG9jdW1lbnRFbGVtZW50J3Mgc2Nyb2xsVG9wL3Njcm9sbExlZnQgb3IgZG9jdW1lbnQuYm9keSdzLiBCYXNpY2FsbHkgdGhpcyBzdHJlYW1saW5lcyB0aGluZ3MgYW5kIG1ha2VzIGEgdmVyeSBmYXN0IGdldHRlciBhY3Jvc3MgYnJvd3NlcnMuXG4gIHZhciBwID0gXCJzY3JvbGxcIiArIChheGlzID09PSBcInhcIiA/IFwiTGVmdFwiIDogXCJUb3BcIik7XG5cbiAgaWYgKGUgPT09IF93aW5kb3cpIHtcbiAgICBpZiAoZS5wYWdlWE9mZnNldCAhPSBudWxsKSB7XG4gICAgICBwID0gXCJwYWdlXCIgKyBheGlzLnRvVXBwZXJDYXNlKCkgKyBcIk9mZnNldFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gX2RvY0VsW3BdICE9IG51bGwgPyBfZG9jRWwgOiBfYm9keTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlW3BdO1xuICB9O1xufSxcbiAgICBfY2xlYW4gPSBmdW5jdGlvbiBfY2xlYW4odmFsdWUsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUgIT09IFwibWF4XCIgJiYgdmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIiA/IHtcbiAgICAgIHg6IHZhbHVlLFxuICAgICAgeTogdmFsdWVcbiAgICB9IDoge1xuICAgICAgeTogdmFsdWVcbiAgICB9OyAvL2lmIHdlIGRvbid0IHJlY2VpdmUgYW4gb2JqZWN0IGFzIHRoZSBwYXJhbWV0ZXIsIGFzc3VtZSB0aGUgdXNlciBpbnRlbmRzIFwieVwiLlxuICB9IGVsc2UgaWYgKHZhbHVlLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IHZhbHVlLFxuICAgICAgeDogdmFsdWVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiB2YWx1ZSkge1xuICAgICAgcmVzdWx0W3BdID0gcCAhPT0gXCJvbkF1dG9LaWxsXCIgJiYgX2lzRnVuY3Rpb24odmFsdWVbcF0pID8gdmFsdWVbcF0oaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YWx1ZVtwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59LFxuICAgIF9nZXRPZmZzZXQgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0KGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICBlbGVtZW50ID0gX3RvQXJyYXkoZWxlbWVudClbMF07XG5cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJzY3JvbGxUbyB0YXJnZXQgZG9lc24ndCBleGlzdC4gVXNpbmcgMFwiKSB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBpc1Jvb3QgPSAhY29udGFpbmVyIHx8IGNvbnRhaW5lciA9PT0gX3dpbmRvdyB8fCBjb250YWluZXIgPT09IF9ib2R5LFxuICAgICAgY1JlY3QgPSBpc1Jvb3QgPyB7XG4gICAgdG9wOiBfZG9jRWwuY2xpZW50VG9wIC0gKF93aW5kb3cucGFnZVlPZmZzZXQgfHwgX2RvY0VsLnNjcm9sbFRvcCB8fCBfYm9keS5zY3JvbGxUb3AgfHwgMCksXG4gICAgbGVmdDogX2RvY0VsLmNsaWVudExlZnQgLSAoX3dpbmRvdy5wYWdlWE9mZnNldCB8fCBfZG9jRWwuc2Nyb2xsTGVmdCB8fCBfYm9keS5zY3JvbGxMZWZ0IHx8IDApXG4gIH0gOiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBvZmZzZXRzID0ge1xuICAgIHg6IHJlY3QubGVmdCAtIGNSZWN0LmxlZnQsXG4gICAgeTogcmVjdC50b3AgLSBjUmVjdC50b3BcbiAgfTtcblxuICBpZiAoIWlzUm9vdCAmJiBjb250YWluZXIpIHtcbiAgICAvL29ubHkgYWRkIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBpZiBpdCdzIG5vdCB0aGUgd2luZG93L2JvZHkuXG4gICAgb2Zmc2V0cy54ICs9IF9idWlsZEdldHRlcihjb250YWluZXIsIFwieFwiKSgpO1xuICAgIG9mZnNldHMueSArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInlcIikoKTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSxcbiAgICBfcGFyc2VWYWwgPSBmdW5jdGlvbiBfcGFyc2VWYWwodmFsdWUsIHRhcmdldCwgYXhpcywgY3VycmVudFZhbCwgb2Zmc2V0KSB7XG4gIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiA/IHBhcnNlRmxvYXQodmFsdWUpIC0gb2Zmc2V0IDogX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoMikpICogKHZhbHVlLmNoYXJBdCgwKSA9PT0gXCItXCIgPyAtMSA6IDEpICsgY3VycmVudFZhbCAtIG9mZnNldCA6IHZhbHVlID09PSBcIm1heFwiID8gX21heCh0YXJnZXQsIGF4aXMpIC0gb2Zmc2V0IDogTWF0aC5taW4oX21heCh0YXJnZXQsIGF4aXMpLCBfZ2V0T2Zmc2V0KHZhbHVlLCB0YXJnZXQpW2F4aXNdIC0gb2Zmc2V0KTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpICYmIGdzYXAgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICBfd2luZG93ID0gd2luZG93O1xuICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBfZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgZ3NhcC5jb25maWcoe1xuICAgICAgYXV0b0tpbGxUaHJlc2hvbGQ6IDdcbiAgICB9KTtcbiAgICBfY29uZmlnID0gZ3NhcC5jb25maWcoKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRvUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTMuMFwiLFxuICBuYW1lOiBcInNjcm9sbFRvXCIsXG4gIHJhd1ZhcnM6IDEsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLFxuICAgICAgICBzbmFwVHlwZSA9IGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbFNuYXBUeXBlXCIpO1xuICAgIGRhdGEuaXNXaW4gPSB0YXJnZXQgPT09IF93aW5kb3c7XG4gICAgZGF0YS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZGF0YS50d2VlbiA9IHR3ZWVuO1xuICAgIHZhbHVlID0gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICBkYXRhLnZhcnMgPSB2YWx1ZTtcbiAgICBkYXRhLmF1dG9LaWxsID0gISEoXCJhdXRvS2lsbFwiIGluIHZhbHVlID8gdmFsdWUgOiBfY29uZmlnKS5hdXRvS2lsbDtcbiAgICBkYXRhLmdldFggPSBfYnVpbGRHZXR0ZXIodGFyZ2V0LCBcInhcIik7XG4gICAgZGF0YS5nZXRZID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ5XCIpO1xuICAgIGRhdGEueCA9IGRhdGEueFByZXYgPSBkYXRhLmdldFgoKTtcbiAgICBkYXRhLnkgPSBkYXRhLnlQcmV2ID0gZGF0YS5nZXRZKCk7XG4gICAgU2Nyb2xsVHJpZ2dlciB8fCAoU2Nyb2xsVHJpZ2dlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsVHJpZ2dlcik7XG4gICAgZ3NhcC5nZXRQcm9wZXJ0eSh0YXJnZXQsIFwic2Nyb2xsQmVoYXZpb3JcIikgPT09IFwic21vb3RoXCIgJiYgZ3NhcC5zZXQodGFyZ2V0LCB7XG4gICAgICBzY3JvbGxCZWhhdmlvcjogXCJhdXRvXCJcbiAgICB9KTtcblxuICAgIGlmIChzbmFwVHlwZSAmJiBzbmFwVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIC8vIGRpc2FibGUgc2Nyb2xsIHNuYXBwaW5nIHRvIGF2b2lkIHN0cmFuZ2UgYmVoYXZpb3JcbiAgICAgIGRhdGEuc25hcCA9IDE7XG4gICAgICBkYXRhLnNuYXBJbmxpbmUgPSB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGU7XG4gICAgICB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUueCAhPSBudWxsKSB7XG4gICAgICBkYXRhLmFkZChkYXRhLCBcInhcIiwgZGF0YS54LCBfcGFyc2VWYWwodmFsdWUueCwgdGFyZ2V0LCBcInhcIiwgZGF0YS54LCB2YWx1ZS5vZmZzZXRYIHx8IDApLCBpbmRleCwgdGFyZ2V0cyk7XG5cbiAgICAgIGRhdGEuX3Byb3BzLnB1c2goXCJzY3JvbGxUb194XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUueSAhPSBudWxsKSB7XG4gICAgICBkYXRhLmFkZChkYXRhLCBcInlcIiwgZGF0YS55LCBfcGFyc2VWYWwodmFsdWUueSwgdGFyZ2V0LCBcInlcIiwgZGF0YS55LCB2YWx1ZS5vZmZzZXRZIHx8IDApLCBpbmRleCwgdGFyZ2V0cyk7XG5cbiAgICAgIGRhdGEuX3Byb3BzLnB1c2goXCJzY3JvbGxUb195XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZID0gMTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICAgIHRhcmdldCA9IGRhdGEudGFyZ2V0LFxuICAgICAgICB0d2VlbiA9IGRhdGEudHdlZW4sXG4gICAgICAgIGF1dG9LaWxsID0gZGF0YS5hdXRvS2lsbCxcbiAgICAgICAgeFByZXYgPSBkYXRhLnhQcmV2LFxuICAgICAgICB5UHJldiA9IGRhdGEueVByZXYsXG4gICAgICAgIGlzV2luID0gZGF0YS5pc1dpbixcbiAgICAgICAgc25hcCA9IGRhdGEuc25hcCxcbiAgICAgICAgc25hcElubGluZSA9IGRhdGEuc25hcElubGluZSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeURpZixcbiAgICAgICAgeERpZixcbiAgICAgICAgdGhyZXNob2xkO1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgeCA9IGlzV2luIHx8ICFkYXRhLnNraXBYID8gZGF0YS5nZXRYKCkgOiB4UHJldjtcbiAgICB5ID0gaXNXaW4gfHwgIWRhdGEuc2tpcFkgPyBkYXRhLmdldFkoKSA6IHlQcmV2O1xuICAgIHlEaWYgPSB5IC0geVByZXY7XG4gICAgeERpZiA9IHggLSB4UHJldjtcbiAgICB0aHJlc2hvbGQgPSBfY29uZmlnLmF1dG9LaWxsVGhyZXNob2xkO1xuXG4gICAgaWYgKGRhdGEueCA8IDApIHtcbiAgICAgIC8vY2FuJ3Qgc2Nyb2xsIHRvIGEgcG9zaXRpb24gbGVzcyB0aGFuIDAhIE1pZ2h0IGhhcHBlbiBpZiBzb21lb25lIHVzZXMgYSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoZW4gc2Nyb2xsaW5nIGJhY2sgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSAoZm9yIGV4YW1wbGUpXG4gICAgICBkYXRhLnggPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnkgPCAwKSB7XG4gICAgICBkYXRhLnkgPSAwO1xuICAgIH1cblxuICAgIGlmIChhdXRvS2lsbCkge1xuICAgICAgLy9ub3RlOiBpT1MgaGFzIGEgYnVnIHRoYXQgdGhyb3dzIG9mZiB0aGUgc2Nyb2xsIGJ5IHNldmVyYWwgcGl4ZWxzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3Mgd2l0aGluIDcgcGl4ZWxzIG9mIHRoZSBwcmV2aW91cyBvbmUgdGhhdCB3ZSBzZXQgaW5zdGVhZCBvZiBqdXN0IGxvb2tpbmcgZm9yIGFuIGV4YWN0IG1hdGNoLlxuICAgICAgaWYgKCFkYXRhLnNraXBYICYmICh4RGlmID4gdGhyZXNob2xkIHx8IHhEaWYgPCAtdGhyZXNob2xkKSAmJiB4IDwgX21heCh0YXJnZXQsIFwieFwiKSkge1xuICAgICAgICBkYXRhLnNraXBYID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuc2tpcFkgJiYgKHlEaWYgPiB0aHJlc2hvbGQgfHwgeURpZiA8IC10aHJlc2hvbGQpICYmIHkgPCBfbWF4KHRhcmdldCwgXCJ5XCIpKSB7XG4gICAgICAgIGRhdGEuc2tpcFkgPSAxOyAvL2lmIHRoZSB1c2VyIHNjcm9sbHMgc2VwYXJhdGVseSwgd2Ugc2hvdWxkIHN0b3AgdHdlZW5pbmchXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLnNraXBYICYmIGRhdGEuc2tpcFkpIHtcbiAgICAgICAgdHdlZW4ua2lsbCgpO1xuICAgICAgICBkYXRhLnZhcnMub25BdXRvS2lsbCAmJiBkYXRhLnZhcnMub25BdXRvS2lsbC5hcHBseSh0d2VlbiwgZGF0YS52YXJzLm9uQXV0b0tpbGxQYXJhbXMgfHwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1dpbikge1xuICAgICAgX3dpbmRvdy5zY3JvbGxUbyghZGF0YS5za2lwWCA/IGRhdGEueCA6IHgsICFkYXRhLnNraXBZID8gZGF0YS55IDogeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc2tpcFkgfHwgKHRhcmdldC5zY3JvbGxUb3AgPSBkYXRhLnkpO1xuICAgICAgZGF0YS5za2lwWCB8fCAodGFyZ2V0LnNjcm9sbExlZnQgPSBkYXRhLngpO1xuICAgIH1cblxuICAgIGlmIChzbmFwICYmIChyYXRpbyA9PT0gMSB8fCByYXRpbyA9PT0gMCkpIHtcbiAgICAgIHkgPSB0YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgeCA9IHRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgc25hcElubGluZSA/IHRhcmdldC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IHNuYXBJbmxpbmUgOiB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY3JvbGwtc25hcC10eXBlXCIpO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHkgKyAxOyAvLyBidWcgaW4gU2FmYXJpIGNhdXNlcyB0aGUgZWxlbWVudCB0byB0b3RhbGx5IHJlc2V0IGl0cyBzY3JvbGwgcG9zaXRpb24gd2hlbiBzY3JvbGwtc25hcC10eXBlIGNoYW5nZXMsIHNvIHdlIG5lZWQgdG8gc2V0IGl0IHRvIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHZhbHVlIGFuZCB0aGVuIGJhY2sgYWdhaW4gdG8gd29yayBhcm91bmQgdGhpcyBidWcuXG5cbiAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0geCArIDE7XG4gICAgICB0YXJnZXQuc2Nyb2xsVG9wID0geTtcbiAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0geDtcbiAgICB9XG5cbiAgICBkYXRhLnhQcmV2ID0gZGF0YS54O1xuICAgIGRhdGEueVByZXYgPSBkYXRhLnk7XG4gICAgU2Nyb2xsVHJpZ2dlciAmJiBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpO1xuICB9LFxuICBraWxsOiBmdW5jdGlvbiBraWxsKHByb3BlcnR5KSB7XG4gICAgdmFyIGJvdGggPSBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb1wiLFxuICAgICAgICBpID0gdGhpcy5fcHJvcHMuaW5kZXhPZihwcm9wZXJ0eSk7XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb194XCIpIHtcbiAgICAgIHRoaXMuc2tpcFggPSAxO1xuICAgIH1cblxuICAgIGlmIChib3RoIHx8IHByb3BlcnR5ID09PSBcInNjcm9sbFRvX3lcIikge1xuICAgICAgdGhpcy5za2lwWSA9IDE7XG4gICAgfVxuXG4gICAgaSA+IC0xICYmIHRoaXMuX3Byb3BzLnNwbGljZShpLCAxKTtcbiAgICByZXR1cm4gIXRoaXMuX3Byb3BzLmxlbmd0aDtcbiAgfVxufTtcblNjcm9sbFRvUGx1Z2luLm1heCA9IF9tYXg7XG5TY3JvbGxUb1BsdWdpbi5nZXRPZmZzZXQgPSBfZ2V0T2Zmc2V0O1xuU2Nyb2xsVG9QbHVnaW4uYnVpbGRHZXR0ZXIgPSBfYnVpbGRHZXR0ZXI7XG5cblNjcm9sbFRvUGx1Z2luLmNvbmZpZyA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIF9jb25maWcgfHwgX2luaXRDb3JlKCkgfHwgKF9jb25maWcgPSBnc2FwLmNvbmZpZygpKTsgLy8gaW4gY2FzZSB0aGUgd2luZG93IGhhc24ndCBiZWVuIGRlZmluZWQgeWV0LlxuXG4gIGZvciAodmFyIHAgaW4gdmFycykge1xuICAgIF9jb25maWdbcF0gPSB2YXJzW3BdO1xuICB9XG59O1xuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVG9QbHVnaW4pO1xuZXhwb3J0IHsgU2Nyb2xsVG9QbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/gsap/ScrollToPlugin.js\n"));

/***/ })

}]);